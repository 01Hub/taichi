{% extends "layout.html" %}
{% block body %}
<script src="../viewer/three.min.js"></script>
<script src="../viewer/TrackballControls.js"></script>
<script src="../viewer/stats.min.js"></script>
<script type="x-shader/x-vertex" id="vertexshader">
			attribute float size;
			attribute vec3 customColor;
			varying vec3 vColor;
			void main() {
				vColor = customColor;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				//gl_PointSize = max(5.0, size * ( 300.0 / -mvPosition.z ));
			    gl_PointSize = 1.0;
				gl_Position = projectionMatrix * mvPosition;
			}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( color * vColor, 1.0 );
				//gl_FragColor = gl_FragColor;// * texture2D( texture, gl_PointCoord );
				if ( gl_FragColor.a < ALPHATEST ) discard;
			}
</script>
<h2 id="stat"></h2>
<script type="text/javascript">
    var container, stats;
    var camera, controls, scene, renderer;
    var objects = [];
    init();
    animate();
    function init() {
        container = document.createElement( 'div' );
        document.body.appendChild( container );
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.001, 100);
        camera.position.x = 0.5;
        camera.position.y = 0.5;
        camera.position.z = 3;
        camera.up = new THREE.Vector3(0,1,0);
        camera.lookAt(new THREE.Vector3(0.5, 0.5, 0.5));
        camera.updateProjectionMatrix();
        controls = new THREE.TrackballControls(camera);
        controls.rotateSpeed = 2.0;
        controls.zoomSpeed = 2.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xf0f0f0 );
        scene.add( new THREE.AmbientLight( 0x505050 ) );

        var light = new THREE.DirectionalLight( 0xffffff, 1 );
        light.position.set(1, 1, 1).normalize();
        scene.add( light );

        var geometry = new THREE.BoxGeometry(1, 1, 1);
        var material = new THREE.MeshPhongMaterial( {
            color: 0xa0adaf,
            shininess: 10,
            specular: 0x111111,
            side: THREE.BackSide
        } );
        var mesh = new THREE.Mesh( geometry, material );
        mesh.position.x = 0.5;
        mesh.position.y = 0.5;
        mesh.position.z = 0.5;
        mesh.receiveShadow = true;
        scene.add( mesh );


        var light = new THREE.SpotLight( 0xffffff, 1.5 );
        light.position.set( 0, 500, 2000 );
        light.castShadow = true; light.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 200, 10000 ) ); light.shadow.bias = - 0.00022;
        light.shadow.mapSize.width = 2048;
        light.shadow.mapSize.height = 2048;
        scene.add( light );
        var geometry = new THREE.BoxGeometry( 0.4, 0.4, 0.4);
        for ( var i = 0; i < 0; i ++ ) {
            var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
            object.position.x = Math.random() * 10 - 5;
            object.position.y = Math.random() * 6 - 3;
            object.position.z = Math.random() * 8 - 4;
            object.rotation.x = Math.random() * 2 * Math.PI;
            object.rotation.y = Math.random() * 2 * Math.PI;
            object.rotation.z = Math.random() * 2 * Math.PI;
            object.scale.x = Math.random() * 2 + 1;
            object.scale.y = Math.random() * 2 + 1;
            object.scale.z = Math.random() * 2 + 1;
            object.castShadow = true;
            object.receiveShadow = true;
            scene.add( object );
            objects.push( object );
        }

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap;
        container.appendChild( renderer.domElement );
        var info = document.createElement( 'div' );
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        container.appendChild( info );
        stats = new Stats();
        container.appendChild( stats.dom );
        window.addEventListener( 'resize', onWindowResize, false );

        window.frameId = 0;
        window.geometries = {}
        window.playing = false;
        // http://keycode.info/
        document.addEventListener('keydown', function(event) {
            if(event.keyCode == 39) {
                refreshFrame(+1);
            }
            else if(event.keyCode == 37) {
                window.frameId -= 1;
                refreshFrame(-1);
            } else if(event.keyCode == 80) { // 'p'
                window.playing = !window.playing;
            }
        });
        refreshFrame(0);
    }

    function pad_with_zero(num, size) {
        var s = "000000000000000" + num;
        return s.substr(s.length-size);
    }

    function refreshFrame(inc) {
        var json = {
            path: '{{folder}}/frames/',
            frame_id:window.frameId,
            inc: inc,
            need_geometry: false
        };
        loadJSON(json,
            function(data) {
                reload(window.frameId);
                window.frameId = data.next_frame;
            },
            function(xhr) { console.error(xhr); }
        );
    }

    // Based on
    // https://stackoverflow.com/questions/9838812/how-can-i-open-a-json-file-in-javascript-without-jquery
    // https://stackoverflow.com/questions/4116992/how-to-include-json-data-in-javascript-synchronously-without-parsing
    function loadJSON(json, success, error)
    {
        var sync=true;
        if (sync) {
            var xmlhttp=new XMLHttpRequest();
            xmlhttp.open("POST",'../data',false);
            xmlhttp.setRequestHeader("Content-Type", "application/json");
            xmlhttp.send(JSON.stringify(json));
            if (xmlhttp.status==200)
            {
                success(JSON.parse(xmlhttp.responseText));
            }
            else {
                error(xmlhttp);
                return null;
            }
        } else {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function()
            {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    if (xhr.status === 200) {
                        if (success)
                            success(JSON.parse(xhr.responseText));
                    } else {
                        if (error)
                            error(xhr);
                    }
                }
            };
            xhr.open("POST", path, true);
            xhr.send();
        }
    }

    function get_geometry(frame_id) {
        if (!(frame_id in window.geometries)) {
            // Load
            var data={};
            var json = {
                path: '{{folder}}/frames/',
                frame_id:frame_id,
                inc: 0,
                need_geometry: true
            };
            loadJSON(json,
                function(data_) {
                    data = data_.data;
                },
                function(xhr) { console.error(xhr); }
            );

            var group = new THREE.Group();
            {
                // Points
                var positions = new Float32Array(data.points.position);
                var colors = new Float32Array(data.points.color);
                var sizes = new Float32Array(data.points.sizes);

                window.num_particles = positions.length / 3;

                var geometry = new THREE.BufferGeometry();
                geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
                geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

                var material = new THREE.ShaderMaterial( {
                    uniforms: {
                        color:   { value: new THREE.Color( 0xffffff ) },
                        texture: { value: new THREE.TextureLoader().load( "disc.png" ) }
                    },
                    vertexShader: document.getElementById( 'vertexshader' ).textContent,
                    fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
                    alphaTest: 0.9
                } );
                var particles = new THREE.Points( geometry, material );
                group.add(particles);
            }
            window.geometries[frame_id] = group;
        }
        return window.geometries[frame_id]
    }

    function reload(frameId) {
        var particles = get_geometry(frameId);
        if (window.particles) {
            scene.remove(window.particles);
        }
        scene.add(particles);

        window.particles = particles;

        document.getElementById("stat").innerHTML = "Frame: " + window.frameId + "  # Particles: " + (window.num_particles)
    }
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }
    function animate() {
        requestAnimationFrame( animate );
        render();
        stats.update();
        if (window.playing) {
            refreshFrame(1);
        }
    }
    function render() {
        controls.update();
        renderer.render( scene, camera );
    }
</script>

{% endblock %}